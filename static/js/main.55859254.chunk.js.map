{"version":3,"sources":["components/Canvas.tsx","types.ts","readFileAsHtmlImage.ts","image.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Canvas","props","canvasRef","React","createRef","imgData","this","clone","omitNonNormalProps","ref","width","height","renderImgData","current","getContext","putImageData","Component","Queue","data","dequeueIndex","item","push","hasItem","undefined","Error","length","History","undoStack","redoStack","history","empty","canUndo","undone","pop","canRedo","redone","Option","none","some","slice","reverse","past","readFileAsHtmlImage","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","error","readAsDataURL","readFileAsDataUrl","then","url","img","document","createElement","src","getImgDataAfterFloodFill","originalData","fill","original","startLocation","replacementRgbColor","replacementColor","colorComparisonOptions","newData","ImageData","getRgbaU8FromRgb","targetColor","getPixelColorAt","isColorCloseEnoughToTarget","options","tolerance","shouldCompareAlpha","tolSq","color","dr","r","dg","g","db","b","da","a","getColorComparator","areColorsEqual","imgWidth","imgHeight","writePixel","queue","enqueue","location","dequeue","getWestNeighbor","ifSome","neighbor","neighborColor","getNorthNeighbor","getEastNeighbor","getSouthNeighbor","rgb","Math","floor","x","y","RangeError","i","c1","c2","App","mainCanvasRef","snapshotsRef","currentSnapshotRef","window","app","state","fileName","shouldBackdropBeCheckered","backdropColorHex","toleranceStr","isAdjustingPreviousFill","bindMethods","onKeyDown","bind","onFileChange","onReplacementColorChangeComplete","onCanvasClick","onToleranceChange","onShouldCompareAlphaChange","onUndoClick","onRedoClick","onBackdropColorChangeComplete","onShouldBackdropBeCheckeredChange","onStopAdjustingPreviousFillClick","onAdjustPreviousFillClick","removeEventListener","event","activeElement","body","key","toLowerCase","ctrlKey","metaKey","preventDefault","shiftKey","redo","undo","match","type","accept","onChange","onClick","disabled","andThen","isNone","onChangeComplete","checked","disableAlpha","value","min","max","ceil","getMaxEuclideanDistance","snapshot","className","style","backgroundColor","imgDataAfterFill","map","future","files","target","File","test","name","setState","or","canvas","ctx","drawImage","getImageData","getImgData","fromCurrent","adjustPreviousFill","all","floodStartLocation","currentSnapshot","clientX","clientY","dataBefore","box","getBoundingClientRect","round","left","top","parseInt","newSnapshot","forceUpdate","fillUpdate","expect","previousSnapshot","prev","updatedFill","prevFill","update","newTolerance","newShouldCompareAlpha","applyFillUpdate","scrollHistoryToCurrentSnapshot","hex","snapshotsContainer","snapshotsContainerWidth","currentSnapshotRight","right","scroll","scrollLeft","hypot","Boolean","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.55859254.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default class Canvas extends React.Component<Props> {\n  private canvasRef: React.RefObject<HTMLCanvasElement>;\n\n  constructor(props: Props) {\n    super(props);\n\n    this.canvasRef = props.canvasRef || React.createRef();\n  }\n\n  render() {\n    const { imgData } = this.props;\n    return (\n      <canvas\n        {...omitNonNormalProps(this.props)}\n        ref={this.canvasRef}\n        width={imgData.width}\n        height={imgData.height}\n      />\n    );\n  }\n\n  componentDidMount() {\n    this.renderImgData();\n  }\n\n  componentDidUpdate() {\n    this.renderImgData();\n  }\n\n  renderImgData() {\n    const canvas = this.canvasRef.current!;\n    const ctx = canvas.getContext(\"2d\")!;\n    ctx.putImageData(this.props.imgData, 0, 0);\n  }\n}\n\ninterface Props extends React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  imgData: ImageData;\n  canvasRef?: React.RefObject<HTMLCanvasElement>;\n}\n\nfunction omitNonNormalProps(\n  props: Props\n): React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  const clone = { ...props };\n\n  delete clone.imgData;\n  delete clone.canvasRef;\n\n  return clone;\n}\n","import Option from \"@kylejlin/option\";\nimport { RGBColor } from \"react-color\";\n\nexport interface RgbaU8 {\n  r: number;\n  b: number;\n  g: number;\n  a: number;\n}\n\nexport interface ColorComparisonOptions {\n  tolerance: number;\n  shouldCompareAlpha: boolean;\n}\n\nexport interface Fill {\n  startLocation: { x: number; y: number };\n  replacementColor: RGBColor;\n  colorComparisonOptions: ColorComparisonOptions;\n}\n\nexport interface FillUpdate {\n  startLocation?: Fill[\"startLocation\"];\n  replacementColor?: Fill[\"replacementColor\"];\n  colorComparisonOptions?: Partial<Fill[\"colorComparisonOptions\"]>;\n}\n\nexport interface Snapshot {\n  fill: Option<Fill>;\n  imgDataAfterFill: ImageData;\n}\n\nexport class Queue<T> {\n  private data: (T | undefined)[];\n  private dequeueIndex: number;\n\n  static empty<T>(): Queue<T> {\n    return new Queue([]);\n  }\n\n  private constructor(data: T[]) {\n    this.data = data;\n    this.dequeueIndex = 0;\n  }\n\n  enqueue(item: T): void {\n    this.data.push(item);\n  }\n\n  dequeue(): T {\n    if (this.hasItem()) {\n      const item = this.data[this.dequeueIndex];\n      this.data[this.dequeueIndex] = undefined;\n      this.dequeueIndex++;\n      return item!;\n    } else {\n      throw new Error(\"Cannot dequeue an item from an empty queue.\");\n    }\n  }\n\n  hasItem(): boolean {\n    return this.dequeueIndex < this.data.length;\n  }\n}\n\nexport class History<T> {\n  private undoStack: T[];\n  private redoStack: T[];\n\n  static fromCurrent<T>(current: T): History<T> {\n    const history: History<T> = History.empty();\n    history.push(current);\n    return history;\n  }\n\n  static empty<T>(): History<T> {\n    return new History();\n  }\n\n  private constructor() {\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  undo(): T {\n    if (!this.canUndo()) {\n      throw new Error(\"Cannot undo nothing.\");\n    }\n\n    const undone = this.undoStack.pop()!;\n    this.redoStack.push(undone);\n    return undone;\n  }\n\n  canUndo(): boolean {\n    return this.undoStack.length > 1;\n  }\n\n  redo(): T {\n    if (!this.canRedo()) {\n      throw new Error(\"Cannot redo nothing.\");\n    }\n\n    const redone = this.redoStack.pop()!;\n    this.undoStack.push(redone);\n    return redone;\n  }\n\n  canRedo(): boolean {\n    return this.redoStack.length > 0;\n  }\n\n  push(item: T) {\n    this.undoStack.push(item);\n    this.redoStack = [];\n  }\n\n  current(): Option<T> {\n    if (this.undoStack.length === 0) {\n      return Option.none();\n    } else {\n      return Option.some(this.undoStack[this.undoStack.length - 1]);\n    }\n  }\n\n  past(): T[] {\n    return this.undoStack.slice(0, -1);\n  }\n\n  future(): T[] {\n    return this.redoStack.slice().reverse();\n  }\n\n  prev(): Option<T> {\n    const past = this.past();\n    if (past.length > 0) {\n      return Option.some(past[past.length - 1]);\n    } else {\n      return Option.none();\n    }\n  }\n}\n","export default function readFileAsHtmlImage(\n  file: File\n): Promise<HTMLImageElement> {\n  return readFileAsDataUrl(file).then(\n    url =>\n      new Promise((resolve, reject) => {\n        const img = document.createElement(\"img\");\n        img.src = url;\n        img.addEventListener(\"load\", () => resolve(img));\n        img.addEventListener(\"error\", reject);\n      })\n  );\n}\n\nfunction readFileAsDataUrl(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", () => resolve(reader.result as string));\n    reader.addEventListener(\"error\", () => reject(reader.error));\n    reader.readAsDataURL(file);\n  });\n}\n","import Option from \"@kylejlin/option\";\nimport { RGBColor } from \"react-color\";\n\nimport { ColorComparisonOptions, Queue, RgbaU8, Fill } from \"./types\";\n\nexport function getImgData(img: HTMLImageElement): ImageData {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext(\"2d\")!;\n  ctx.drawImage(img, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\nexport function doesTargetColorEqualReplacementColor(\n  imgData: ImageData,\n  floodStartLocation: { x: number; y: number },\n  replacementRgbColor: RGBColor\n): boolean {\n  const replacementColor = getRgbaU8FromRgb(replacementRgbColor);\n  const targetColor = getPixelColorAt(imgData, floodStartLocation);\n  return areColorsEqual(replacementColor, targetColor);\n}\n\nexport function getImgDataAfterFloodFill(\n  originalData: ImageData,\n  fill: Fill\n): ImageData {\n  const {\n    startLocation,\n    replacementColor: replacementRgbColor,\n    colorComparisonOptions\n  } = fill;\n  const newData = cloneImgData(originalData);\n  const replacementColor = getRgbaU8FromRgb(replacementRgbColor);\n  const targetColor = getPixelColorAt(newData, startLocation);\n  const isColorCloseEnoughToTarget = getColorComparator(\n    targetColor,\n    colorComparisonOptions\n  );\n\n  if (areColorsEqual(replacementColor, targetColor)) {\n    return newData;\n  }\n\n  const { width: imgWidth, height: imgHeight } = originalData;\n\n  writePixel(newData, startLocation, replacementColor);\n\n  const queue: Queue<{ x: number; y: number }> = Queue.empty();\n  queue.enqueue(startLocation);\n\n  while (queue.hasItem()) {\n    const location = queue.dequeue();\n    getWestNeighbor(location).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getNorthNeighbor(location).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getEastNeighbor(location, imgWidth).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getSouthNeighbor(location, imgHeight).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n  }\n\n  return newData;\n}\n\nfunction cloneImgData(original: ImageData): ImageData {\n  return new ImageData(original.data.slice(), original.width, original.height);\n}\n\nfunction getRgbaU8FromRgb(rgb: RGBColor): RgbaU8 {\n  return {\n    r: rgb.r,\n    g: rgb.g,\n    b: rgb.b,\n    a: Math.floor(255 * (rgb.a === undefined ? 1.0 : rgb.a))\n  };\n}\n\nfunction getPixelColorAt(\n  imgData: ImageData,\n  { x, y }: { x: number; y: number }\n): RgbaU8 {\n  const { width, height, data } = imgData;\n  if (x >= width) {\n    throw new RangeError(\"X coordinate exceeded image width.\");\n  }\n  if (y >= height) {\n    throw new RangeError(\"Y coordinate exceeded image height.\");\n  }\n  const i = 4 * (y * width + x);\n  return { r: data[i], g: data[i + 1], b: data[i + 2], a: data[i + 3] };\n}\n\nfunction getColorComparator(\n  targetColor: RgbaU8,\n  options: ColorComparisonOptions\n): (color: RgbaU8) => boolean {\n  const { tolerance, shouldCompareAlpha } = options;\n  const tolSq = tolerance * tolerance;\n\n  if (shouldCompareAlpha) {\n    return function isColorCloseEnoughToTarget(color: RgbaU8): boolean {\n      const dr = targetColor.r - color.r;\n      const dg = targetColor.g - color.g;\n      const db = targetColor.b - color.b;\n      const da = targetColor.a - color.a;\n      const distSq = dr * dr + dg * dg + db * db + da * da;\n      return distSq <= tolSq;\n    };\n  } else {\n    return function isColorCloseEnoughToTarget(color: RgbaU8): boolean {\n      const dr = targetColor.r - color.r;\n      const dg = targetColor.g - color.g;\n      const db = targetColor.b - color.b;\n      const distSq = dr * dr + dg * dg + db * db;\n      return distSq <= tolSq;\n    };\n  }\n}\n\nfunction areColorsEqual(c1: RgbaU8, c2: RgbaU8): boolean {\n  return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;\n}\n\nfunction writePixel(\n  imgData: ImageData,\n  { x, y }: { x: number; y: number },\n  color: RgbaU8\n): void {\n  const { width, height, data } = imgData;\n\n  if (x >= width) {\n    throw new RangeError(\"X coordinate exceeded image width.\");\n  }\n  if (y >= height) {\n    throw new RangeError(\"Y coordinate exceeded image height.\");\n  }\n\n  const i = 4 * (y * width + x);\n\n  data[i] = color.r;\n  data[i + 1] = color.g;\n  data[i + 2] = color.b;\n  data[i + 3] = color.a;\n}\n\nfunction getWestNeighbor({\n  x,\n  y\n}: {\n  x: number;\n  y: number;\n}): Option<{ x: number; y: number }> {\n  if (x > 0) {\n    return Option.some({ x: x - 1, y });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getNorthNeighbor({\n  x,\n  y\n}: {\n  x: number;\n  y: number;\n}): Option<{ x: number; y: number }> {\n  if (y > 0) {\n    return Option.some({ x, y: y - 1 });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getEastNeighbor(\n  {\n    x,\n    y\n  }: {\n    x: number;\n    y: number;\n  },\n  width: number\n): Option<{ x: number; y: number }> {\n  if (x < width - 1) {\n    return Option.some({ x: x + 1, y });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getSouthNeighbor(\n  {\n    x,\n    y\n  }: {\n    x: number;\n    y: number;\n  },\n  height: number\n): Option<{ x: number; y: number }> {\n  if (y < height - 1) {\n    return Option.some({ x, y: y + 1 });\n  } else {\n    return Option.none();\n  }\n}\n","import React from \"react\";\nimport Option from \"@kylejlin/option\";\nimport { SketchPicker, ColorResult, RGBColor } from \"react-color\";\n\nimport \"./App.css\";\n\nimport Canvas from \"./components/Canvas\";\n\nimport {\n  History,\n  Snapshot,\n  Fill,\n  ColorComparisonOptions,\n  FillUpdate\n} from \"./types\";\n\nimport readFileAsHtmlImage from \"./readFileAsHtmlImage\";\nimport {\n  doesTargetColorEqualReplacementColor,\n  getImgData,\n  getImgDataAfterFloodFill\n} from \"./image\";\n\nexport default class App extends React.Component<{}, State> {\n  private mainCanvasRef: React.RefObject<HTMLCanvasElement>;\n  private snapshotsRef: React.RefObject<HTMLDivElement>;\n  private currentSnapshotRef: React.RefObject<HTMLCanvasElement>;\n\n  constructor(props: {}) {\n    super(props);\n\n    // @ts-ignore\n    window.app = this;\n\n    this.state = {\n      fileName: Option.none(),\n      shouldBackdropBeCheckered: true,\n      backdropColorHex: \"#222222\",\n      history: Option.none(),\n      replacementColor: Option.none(),\n      toleranceStr: \"0\",\n      shouldCompareAlpha: false,\n      isAdjustingPreviousFill: false\n    };\n\n    this.bindMethods();\n\n    this.mainCanvasRef = React.createRef();\n    this.snapshotsRef = React.createRef();\n    this.currentSnapshotRef = React.createRef();\n  }\n\n  bindMethods() {\n    this.onKeyDown = this.onKeyDown.bind(this);\n\n    this.onFileChange = this.onFileChange.bind(this);\n    this.onReplacementColorChangeComplete = this.onReplacementColorChangeComplete.bind(\n      this\n    );\n    this.onCanvasClick = this.onCanvasClick.bind(this);\n    this.onToleranceChange = this.onToleranceChange.bind(this);\n    this.onShouldCompareAlphaChange = this.onShouldCompareAlphaChange.bind(\n      this\n    );\n    this.onUndoClick = this.onUndoClick.bind(this);\n    this.onRedoClick = this.onRedoClick.bind(this);\n    this.onBackdropColorChangeComplete = this.onBackdropColorChangeComplete.bind(\n      this\n    );\n    this.onShouldBackdropBeCheckeredChange = this.onShouldBackdropBeCheckeredChange.bind(\n      this\n    );\n    this.onStopAdjustingPreviousFillClick = this.onStopAdjustingPreviousFillClick.bind(\n      this\n    );\n    this.onAdjustPreviousFillClick = this.onAdjustPreviousFillClick.bind(this);\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  onKeyDown(event: KeyboardEvent) {\n    if (\n      document.activeElement === document.body &&\n      event.key.toLowerCase() === \"z\" &&\n      (event.ctrlKey || event.metaKey) &&\n      !this.state.isAdjustingPreviousFill\n    ) {\n      event.preventDefault();\n      if (event.shiftKey) {\n        this.state.history.ifSome(history => {\n          if (history.canRedo()) {\n            this.redo();\n          }\n        });\n      } else {\n        this.state.history.ifSome(history => {\n          if (history.canUndo()) {\n            this.undo();\n          }\n        });\n      }\n    }\n  }\n\n  render() {\n    return (\n      <>\n        <header>\n          <h1>Flood fill</h1>\n        </header>\n        <main>\n          <div>\n            {this.state.fileName.match({\n              none: () => (\n                <label>\n                  Upload an image{\" \"}\n                  <input\n                    type=\"file\"\n                    accept=\"image/png, image/jpg, image/jpeg, image/gif\"\n                    onChange={this.onFileChange}\n                  />\n                </label>\n              ),\n              some: fileName =>\n                this.state.history.match({\n                  none: () => <p>Loading {fileName}...</p>,\n                  some: () => (\n                    <>\n                      <p>Successfully uploaded {fileName}</p>\n                      <label>\n                        Choose another image{\" \"}\n                        <input\n                          type=\"file\"\n                          accept=\"image/png, image/jpg, image/jpeg, image/gif\"\n                          onChange={this.onFileChange}\n                        />\n                      </label>\n                    </>\n                  )\n                })\n            })}\n          </div>\n\n          {this.state.replacementColor.match({\n            none: () => null,\n            some: color => (\n              <div>\n                {this.state.isAdjustingPreviousFill ? (\n                  <div>\n                    <h3>Adjusting the previous fill</h3>\n                    <p>\n                      Any changes you make to the fill settings (including\n                      changing the flood start location by clicking on the\n                      image) will adjust the previous fill.\n                    </p>\n                    <button onClick={this.onStopAdjustingPreviousFillClick}>\n                      Stop adjusting\n                    </button>\n                  </div>\n                ) : (\n                  <div>\n                    <h3>Adjusting next fill</h3>\n                    <p>\n                      Any changes you make to the fill settings will apply to\n                      the next fill performed. Clicking on the image will cause\n                      a new fill to be performed.\n                    </p>\n                    <button\n                      onClick={this.onAdjustPreviousFillClick}\n                      disabled={this.state.history\n                        .andThen(history =>\n                          history.current().andThen(current => current.fill)\n                        )\n                        .isNone()}\n                    >\n                      Adjust previous fill\n                    </button>\n                  </div>\n                )}\n\n                <label>\n                  Replacement color:\n                  <SketchPicker\n                    color={color}\n                    onChangeComplete={this.onReplacementColorChangeComplete}\n                  />\n                </label>\n\n                <section>\n                  <h3>Backdrop</h3>\n                  <label>\n                    Use checkerboard:{\" \"}\n                    <input\n                      type=\"checkbox\"\n                      checked={this.state.shouldBackdropBeCheckered}\n                      onChange={this.onShouldBackdropBeCheckeredChange}\n                    />\n                    {!this.state.shouldBackdropBeCheckered && (\n                      <label>\n                        Color:\n                        <SketchPicker\n                          disableAlpha\n                          color={this.state.backdropColorHex}\n                          onChangeComplete={this.onBackdropColorChangeComplete}\n                        />\n                      </label>\n                    )}\n                  </label>\n                </section>\n\n                <label>\n                  Tolerance:{\" \"}\n                  <input\n                    type=\"number\"\n                    value={this.state.toleranceStr}\n                    onChange={this.onToleranceChange}\n                  />\n                  <input\n                    type=\"range\"\n                    value={this.state.toleranceStr}\n                    onChange={this.onToleranceChange}\n                    min={0}\n                    max={Math.ceil(\n                      getMaxEuclideanDistance(this.state.shouldCompareAlpha)\n                    )}\n                  />\n                </label>\n                <label>\n                  Compare alpha values:{\" \"}\n                  <input\n                    type=\"checkbox\"\n                    checked={this.state.shouldCompareAlpha}\n                    onChange={this.onShouldCompareAlphaChange}\n                  />\n                </label>\n              </div>\n            )\n          })}\n\n          {this.state.history\n            .andThen(history => history.current())\n            .match({\n              none: () => null,\n              some: snapshot => (\n                <div\n                  className={\n                    \"MainCanvasContainer\" +\n                    (this.state.shouldBackdropBeCheckered\n                      ? \" Checkerboard\"\n                      : \"\")\n                  }\n                  {...(this.state.shouldBackdropBeCheckered\n                    ? {}\n                    : {\n                        style: {\n                          backgroundColor: this.state.backdropColorHex\n                        }\n                      })}\n                >\n                  <Canvas\n                    imgData={snapshot.imgDataAfterFill}\n                    canvasRef={this.mainCanvasRef}\n                    className={\"MainCanvas\"}\n                    onClick={this.onCanvasClick}\n                  />\n                </div>\n              )\n            })}\n\n          {this.state.history.match({\n            none: () => null,\n            some: history => (\n              <div>\n                <h3>History</h3>\n\n                {this.state.isAdjustingPreviousFill && (\n                  <p>\n                    You cannot undo or redo because you are adjusting the\n                    previous fill. To be able to undo and redo, stop adjusting\n                    the previous fill.\n                  </p>\n                )}\n\n                <button\n                  onClick={this.onUndoClick}\n                  disabled={\n                    !history.canUndo() || this.state.isAdjustingPreviousFill\n                  }\n                >\n                  Undo\n                </button>\n\n                <button\n                  onClick={this.onRedoClick}\n                  disabled={\n                    !history.canRedo() || this.state.isAdjustingPreviousFill\n                  }\n                >\n                  Redo\n                </button>\n\n                {!this.state.isAdjustingPreviousFill && (\n                  <p>\n                    You can also Undo by pressing <kbd>Ctrl-Z</kbd> or{\" \"}\n                    <kbd>Cmd-Z</kbd> and Redo by pressing{\" \"}\n                    <kbd>Ctrl-Shift-Z</kbd> or <kbd>Cmd-Shift-Z</kbd>.\n                  </p>\n                )}\n\n                <div className=\"Snapshots\" ref={this.snapshotsRef}>\n                  {history.past().map((snapshot, i) => (\n                    <Canvas\n                      key={i}\n                      imgData={snapshot.imgDataAfterFill}\n                      className=\"HistorySnapshot NonFinalSnapshot\"\n                    />\n                  ))}\n                  {history.current().match({\n                    none: () => null,\n                    some: snapshot => (\n                      <Canvas\n                        imgData={snapshot.imgDataAfterFill}\n                        className={\n                          \"HistorySnapshot CurrentSnapshot\" +\n                          (history.future().length > 0\n                            ? \" NonFinalSnapshot\"\n                            : \"\")\n                        }\n                        canvasRef={this.currentSnapshotRef}\n                      />\n                    )\n                  })}\n                  {history.future().map((snapshot, i, { length }) => (\n                    <Canvas\n                      key={i}\n                      imgData={snapshot.imgDataAfterFill}\n                      className={\n                        \"HistorySnapshot\" +\n                        (i < length - 1 ? \" NonFinalSnapshot\" : \"\")\n                      }\n                    />\n                  ))}\n                </div>\n              </div>\n            )\n          })}\n        </main>\n      </>\n    );\n  }\n\n  onFileChange(event: React.ChangeEvent<HTMLInputElement>) {\n    const { files } = event.target;\n    if (files !== null) {\n      const file = files[0];\n      if (file instanceof File && /\\.(jpe?g|png|gif)$/i.test(file.name)) {\n        this.setState({\n          fileName: Option.some(file.name),\n          history: Option.none(),\n          replacementColor: this.state.replacementColor.or(\n            Option.some({ r: 0, g: 0, b: 0, a: 0 })\n          ),\n          isAdjustingPreviousFill: false\n        });\n\n        readFileAsHtmlImage(file).then(img => {\n          const imgDataAfterFill = getImgData(img);\n          const snapshot: Snapshot = {\n            fill: Option.none(),\n            imgDataAfterFill\n          };\n\n          this.setState({\n            history: Option.some(History.fromCurrent(snapshot))\n          });\n        });\n      }\n    }\n  }\n\n  onReplacementColorChangeComplete(color: ColorResult) {\n    const replacementColor = color.rgb;\n    this.setState({ replacementColor: Option.some(replacementColor) });\n\n    if (this.state.isAdjustingPreviousFill) {\n      this.adjustPreviousFill({ replacementColor });\n    }\n  }\n\n  onCanvasClick(event: React.MouseEvent<HTMLCanvasElement>) {\n    Option.all([\n      this.state.replacementColor,\n      this.state.history,\n      this.state.history.andThen(history => history.current())\n    ]).ifSome(([replacementColor, history, currentSnapshot]) => {\n      const { clientX, clientY } = event;\n      const canvas = this.mainCanvasRef.current!;\n      const dataBefore = currentSnapshot.imgDataAfterFill;\n\n      const box = canvas.getBoundingClientRect();\n      const localX = Math.round(clientX - box.left);\n      const localY = Math.round(clientY - box.top);\n      const startLocation = { x: localX, y: localY };\n\n      if (\n        doesTargetColorEqualReplacementColor(\n          dataBefore,\n          startLocation,\n          replacementColor\n        )\n      ) {\n        return;\n      }\n\n      if (this.state.isAdjustingPreviousFill) {\n        this.adjustPreviousFill({ startLocation });\n      } else {\n        const colorComparisonOptions: ColorComparisonOptions = {\n          tolerance: parseInt(this.state.toleranceStr, 10),\n          shouldCompareAlpha: this.state.shouldCompareAlpha\n        };\n        const fill: Fill = {\n          startLocation,\n          replacementColor,\n          colorComparisonOptions\n        };\n        const imgDataAfterFill = getImgDataAfterFloodFill(dataBefore, fill);\n        const newSnapshot: Snapshot = {\n          fill: Option.some(fill),\n          imgDataAfterFill\n        };\n\n        history.push(newSnapshot);\n        this.forceUpdate();\n      }\n    });\n  }\n\n  onToleranceChange(event: React.ChangeEvent<HTMLInputElement>) {\n    const toleranceStr = event.target.value;\n    this.setState({ toleranceStr });\n\n    if (this.state.isAdjustingPreviousFill) {\n      this.adjustPreviousFill({\n        colorComparisonOptions: { tolerance: parseInt(toleranceStr, 10) }\n      });\n    }\n  }\n\n  onShouldCompareAlphaChange(event: React.ChangeEvent<HTMLInputElement>) {\n    const shouldCompareAlpha = event.target.checked;\n    this.setState({ shouldCompareAlpha });\n\n    if (this.state.isAdjustingPreviousFill) {\n      this.adjustPreviousFill({\n        colorComparisonOptions: { shouldCompareAlpha }\n      });\n    }\n  }\n\n  adjustPreviousFill(fillUpdate: FillUpdate) {\n    const history = this.state.history.expect(\n      \"Cannot call adjustPreviousFill if there is no history\"\n    );\n    const currentSnapshot = history\n      .current()\n      .expect(\"Cannot call adjustPreviousFill if there is no current snapshot\");\n    const previousSnapshot = history\n      .prev()\n      .expect(\n        \"Cannot call adjustPreviousFill if there is no previous snapshot\"\n      );\n    const previousFill = currentSnapshot.fill.expect(\n      \"Cannot call adjustPreviousFill if the current snapshot was not created by flood-fill\"\n    );\n    const updatedFill = applyFillUpdate(previousFill, fillUpdate);\n\n    currentSnapshot.fill = Option.some(updatedFill);\n    currentSnapshot.imgDataAfterFill = getImgDataAfterFloodFill(\n      previousSnapshot.imgDataAfterFill,\n      updatedFill\n    );\n    this.forceUpdate();\n  }\n\n  onUndoClick() {\n    this.undo();\n  }\n\n  undo() {\n    this.state.history\n      .expect(\"Cannot call onUndoClick if history is none\")\n      .undo();\n    this.forceUpdate(() => {\n      this.scrollHistoryToCurrentSnapshot();\n    });\n  }\n\n  onRedoClick() {\n    this.redo();\n  }\n\n  redo() {\n    this.state.history\n      .expect(\"Cannot call onRedoClick if history is none\")\n      .redo();\n    this.forceUpdate(() => {\n      this.scrollHistoryToCurrentSnapshot();\n    });\n  }\n\n  onBackdropColorChangeComplete(color: ColorResult) {\n    this.setState({ backdropColorHex: color.hex });\n  }\n\n  onShouldBackdropBeCheckeredChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ) {\n    this.setState({ shouldBackdropBeCheckered: event.target.checked });\n  }\n\n  scrollHistoryToCurrentSnapshot() {\n    const currentSnapshot = this.currentSnapshotRef.current;\n    if (currentSnapshot !== null) {\n      const snapshotsContainer = this.snapshotsRef.current!;\n      const snapshotsContainerWidth = snapshotsContainer.getBoundingClientRect()\n        .width;\n      const currentSnapshotRight = currentSnapshot.getBoundingClientRect()\n        .right;\n      snapshotsContainer.scroll(\n        currentSnapshotRight +\n          snapshotsContainer.scrollLeft -\n          snapshotsContainerWidth,\n        0\n      );\n    }\n  }\n\n  onStopAdjustingPreviousFillClick() {\n    this.setState({ isAdjustingPreviousFill: false });\n  }\n\n  onAdjustPreviousFillClick() {\n    this.setState({ isAdjustingPreviousFill: true });\n  }\n}\n\ninterface State {\n  fileName: Option<string>;\n  shouldBackdropBeCheckered: boolean;\n  backdropColorHex: string;\n  history: Option<History<Snapshot>>;\n  replacementColor: Option<RGBColor>;\n  toleranceStr: string;\n  shouldCompareAlpha: boolean;\n  isAdjustingPreviousFill: boolean;\n}\n\nfunction applyFillUpdate(prevFill: Fill, update: FillUpdate): Fill {\n  const newTolerance =\n    update.colorComparisonOptions && update.colorComparisonOptions.tolerance;\n  const newShouldCompareAlpha =\n    update.colorComparisonOptions &&\n    update.colorComparisonOptions.shouldCompareAlpha;\n  return {\n    startLocation: update.startLocation || prevFill.startLocation,\n    replacementColor: update.replacementColor || prevFill.replacementColor,\n    colorComparisonOptions: {\n      tolerance:\n        newTolerance !== undefined\n          ? newTolerance\n          : prevFill.colorComparisonOptions.tolerance,\n      shouldCompareAlpha:\n        newShouldCompareAlpha !== undefined\n          ? newShouldCompareAlpha\n          : prevFill.colorComparisonOptions.shouldCompareAlpha\n    }\n  };\n}\n\nfunction getMaxEuclideanDistance(shouldCompareAlpha: boolean): number {\n  if (shouldCompareAlpha) {\n    return Math.hypot(255, 255, 255, 255);\n  } else {\n    return Math.hypot(255, 255, 255);\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}