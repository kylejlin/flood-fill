{"version":3,"sources":["components/Canvas.tsx","types.ts","readFileAsHtmlImage.ts","image.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Canvas","props","canvasRef","React","createRef","imgData","this","clone","omitNonNormalProps","ref","width","height","renderImgData","current","getContext","putImageData","Component","Queue","data","dequeueIndex","item","push","hasItem","undefined","Error","length","History","undoStack","redoStack","history","empty","canUndo","undone","pop","canRedo","redone","Option","none","some","slice","reverse","past","readFileAsHtmlImage","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","error","readAsDataURL","readFileAsDataUrl","then","url","img","document","createElement","src","getImgDataAfterFloodFill","originalData","fill","original","startLocation","replacementRgbColor","replacementColor","colorComparisonOptions","newData","ImageData","getRgbaU8FromRgb","targetColor","getPixelColorAt","isColorCloseEnoughToTarget","options","tolerance","shouldCompareAlpha","tolSq","color","dr","r","dg","g","db","b","da","a","getColorComparator","areColorsEqual","imgWidth","imgHeight","writePixel","queue","enqueue","location","dequeue","getWestNeighbor","ifSome","neighbor","neighborColor","getNorthNeighbor","getEastNeighbor","getSouthNeighbor","rgb","Math","floor","x","y","RangeError","i","c1","c2","App","mainCanvasRef","snapshotsRef","currentSnapshotRef","window","app","state","fileName","shouldBackdropBeCheckered","backdropColorHex","toleranceStr","isAdjustingPreviousFill","isSelectingReplacementColorFromCurrentSnapshot","pendingFillUpdate","bindMethods","onKeyDown","bind","applyPendingFillUpdate","onFileChange","onReplacementColorChangeComplete","onCanvasClick","onToleranceChange","onShouldCompareAlphaChange","onUndoClick","onRedoClick","onBackdropColorChangeComplete","onShouldBackdropBeCheckeredChange","onStopAdjustingPreviousFillClick","onAdjustPreviousFillClick","onIsSelectingReplacementColorFromCurrentSnapshotChange","removeEventListener","event","activeElement","body","key","toLowerCase","ctrlKey","metaKey","preventDefault","shiftKey","redo","undo","match","type","accept","onChange","onClick","disabled","andThen","isNone","checked","onChangeComplete","disableAlpha","value","min","max","ceil","getMaxEuclideanDistance","snapshot","className","style","backgroundColor","imgDataAfterFill","map","future","files","target","File","test","name","setState","or","canvas","ctx","drawImage","getImageData","getImgData","fromCurrent","adjustPreviousFill","all","currentSnapshot","clientX","clientY","dataBefore","box","getBoundingClientRect","round","left","top","newReplacementColor","parseInt","newSnapshot","forceUpdate","debouncedAdjustPreviousFill","fillUpdate","ifNone","requestAnimationFrame","update","clearPendingFillUpdate","expect","previousSnapshot","prev","updatedFill","prevFill","newTolerance","newShouldCompareAlpha","applyFillUpdate","scrollHistoryToCurrentSnapshot","hex","snapshotsContainer","snapshotsContainerWidth","currentSnapshotRight","right","scroll","scrollLeft","hypot","Boolean","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.d55df956.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default class Canvas extends React.Component<Props> {\n  private canvasRef: React.RefObject<HTMLCanvasElement>;\n\n  constructor(props: Props) {\n    super(props);\n\n    this.canvasRef = props.canvasRef || React.createRef();\n  }\n\n  render() {\n    const { imgData } = this.props;\n    return (\n      <canvas\n        {...omitNonNormalProps(this.props)}\n        ref={this.canvasRef}\n        width={imgData.width}\n        height={imgData.height}\n      />\n    );\n  }\n\n  componentDidMount() {\n    this.renderImgData();\n  }\n\n  componentDidUpdate() {\n    this.renderImgData();\n  }\n\n  renderImgData() {\n    const canvas = this.canvasRef.current!;\n    const ctx = canvas.getContext(\"2d\")!;\n    ctx.putImageData(this.props.imgData, 0, 0);\n  }\n}\n\ninterface Props extends React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  imgData: ImageData;\n  canvasRef?: React.RefObject<HTMLCanvasElement>;\n}\n\nfunction omitNonNormalProps(\n  props: Props\n): React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  const clone = { ...props };\n\n  delete clone.imgData;\n  delete clone.canvasRef;\n\n  return clone;\n}\n","import Option from \"@kylejlin/option\";\nimport { RGBColor } from \"react-color\";\n\nexport interface RgbaU8 {\n  r: number;\n  b: number;\n  g: number;\n  a: number;\n}\n\nexport interface ColorComparisonOptions {\n  tolerance: number;\n  shouldCompareAlpha: boolean;\n}\n\nexport interface Fill {\n  startLocation: { x: number; y: number };\n  replacementColor: RGBColor;\n  colorComparisonOptions: ColorComparisonOptions;\n}\n\nexport interface FillUpdate {\n  startLocation?: Fill[\"startLocation\"];\n  replacementColor?: Fill[\"replacementColor\"];\n  colorComparisonOptions?: Partial<Fill[\"colorComparisonOptions\"]>;\n}\n\nexport interface Snapshot {\n  fill: Option<Fill>;\n  imgDataAfterFill: ImageData;\n}\n\nexport class Queue<T> {\n  private data: (T | undefined)[];\n  private dequeueIndex: number;\n\n  static empty<T>(): Queue<T> {\n    return new Queue([]);\n  }\n\n  private constructor(data: T[]) {\n    this.data = data;\n    this.dequeueIndex = 0;\n  }\n\n  enqueue(item: T): void {\n    this.data.push(item);\n  }\n\n  dequeue(): T {\n    if (this.hasItem()) {\n      const item = this.data[this.dequeueIndex];\n      this.data[this.dequeueIndex] = undefined;\n      this.dequeueIndex++;\n      return item!;\n    } else {\n      throw new Error(\"Cannot dequeue an item from an empty queue.\");\n    }\n  }\n\n  hasItem(): boolean {\n    return this.dequeueIndex < this.data.length;\n  }\n}\n\nexport class History<T> {\n  private undoStack: T[];\n  private redoStack: T[];\n\n  static fromCurrent<T>(current: T): History<T> {\n    const history: History<T> = History.empty();\n    history.push(current);\n    return history;\n  }\n\n  static empty<T>(): History<T> {\n    return new History();\n  }\n\n  private constructor() {\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  undo(): T {\n    if (!this.canUndo()) {\n      throw new Error(\"Cannot undo nothing.\");\n    }\n\n    const undone = this.undoStack.pop()!;\n    this.redoStack.push(undone);\n    return undone;\n  }\n\n  canUndo(): boolean {\n    return this.undoStack.length > 1;\n  }\n\n  redo(): T {\n    if (!this.canRedo()) {\n      throw new Error(\"Cannot redo nothing.\");\n    }\n\n    const redone = this.redoStack.pop()!;\n    this.undoStack.push(redone);\n    return redone;\n  }\n\n  canRedo(): boolean {\n    return this.redoStack.length > 0;\n  }\n\n  push(item: T) {\n    this.undoStack.push(item);\n    this.redoStack = [];\n  }\n\n  current(): Option<T> {\n    if (this.undoStack.length === 0) {\n      return Option.none();\n    } else {\n      return Option.some(this.undoStack[this.undoStack.length - 1]);\n    }\n  }\n\n  past(): T[] {\n    return this.undoStack.slice(0, -1);\n  }\n\n  future(): T[] {\n    return this.redoStack.slice().reverse();\n  }\n\n  prev(): Option<T> {\n    const past = this.past();\n    if (past.length > 0) {\n      return Option.some(past[past.length - 1]);\n    } else {\n      return Option.none();\n    }\n  }\n}\n","export default function readFileAsHtmlImage(\n  file: File\n): Promise<HTMLImageElement> {\n  return readFileAsDataUrl(file).then(\n    url =>\n      new Promise((resolve, reject) => {\n        const img = document.createElement(\"img\");\n        img.src = url;\n        img.addEventListener(\"load\", () => resolve(img));\n        img.addEventListener(\"error\", reject);\n      })\n  );\n}\n\nfunction readFileAsDataUrl(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", () => resolve(reader.result as string));\n    reader.addEventListener(\"error\", () => reject(reader.error));\n    reader.readAsDataURL(file);\n  });\n}\n","import Option from \"@kylejlin/option\";\nimport { RGBColor } from \"react-color\";\n\nimport { ColorComparisonOptions, Queue, RgbaU8, Fill } from \"./types\";\n\nexport function getImgData(img: HTMLImageElement): ImageData {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext(\"2d\")!;\n  ctx.drawImage(img, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\nexport function getImgDataAfterFloodFill(\n  originalData: ImageData,\n  fill: Fill\n): ImageData {\n  const {\n    startLocation,\n    replacementColor: replacementRgbColor,\n    colorComparisonOptions\n  } = fill;\n  const newData = cloneImgData(originalData);\n  const replacementColor = getRgbaU8FromRgb(replacementRgbColor);\n  const targetColor = getPixelColorAt(newData, startLocation);\n  const isColorCloseEnoughToTarget = getColorComparator(\n    targetColor,\n    colorComparisonOptions\n  );\n\n  if (areColorsEqual(replacementColor, targetColor)) {\n    return newData;\n  }\n\n  const { width: imgWidth, height: imgHeight } = originalData;\n\n  writePixel(newData, startLocation, replacementColor);\n\n  const queue: Queue<{ x: number; y: number }> = Queue.empty();\n  queue.enqueue(startLocation);\n\n  while (queue.hasItem()) {\n    const location = queue.dequeue();\n    getWestNeighbor(location).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getNorthNeighbor(location).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getEastNeighbor(location, imgWidth).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getSouthNeighbor(location, imgHeight).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n  }\n\n  return newData;\n}\n\nfunction cloneImgData(original: ImageData): ImageData {\n  return new ImageData(original.data.slice(), original.width, original.height);\n}\n\nexport function getRgbaU8FromRgb(rgb: RGBColor): RgbaU8 {\n  return {\n    r: rgb.r,\n    g: rgb.g,\n    b: rgb.b,\n    a: Math.floor(255 * (rgb.a === undefined ? 1.0 : rgb.a))\n  };\n}\n\nexport function getPixelColorAt(\n  imgData: ImageData,\n  { x, y }: { x: number; y: number }\n): RgbaU8 {\n  const { width, height, data } = imgData;\n  if (x >= width) {\n    throw new RangeError(\"X coordinate exceeded image width.\");\n  }\n  if (y >= height) {\n    throw new RangeError(\"Y coordinate exceeded image height.\");\n  }\n  const i = 4 * (y * width + x);\n  return { r: data[i], g: data[i + 1], b: data[i + 2], a: data[i + 3] };\n}\n\nfunction getColorComparator(\n  targetColor: RgbaU8,\n  options: ColorComparisonOptions\n): (color: RgbaU8) => boolean {\n  const { tolerance, shouldCompareAlpha } = options;\n  const tolSq = tolerance * tolerance;\n\n  if (shouldCompareAlpha) {\n    return function isColorCloseEnoughToTarget(color: RgbaU8): boolean {\n      const dr = targetColor.r - color.r;\n      const dg = targetColor.g - color.g;\n      const db = targetColor.b - color.b;\n      const da = targetColor.a - color.a;\n      const distSq = dr * dr + dg * dg + db * db + da * da;\n      return distSq <= tolSq;\n    };\n  } else {\n    return function isColorCloseEnoughToTarget(color: RgbaU8): boolean {\n      const dr = targetColor.r - color.r;\n      const dg = targetColor.g - color.g;\n      const db = targetColor.b - color.b;\n      const distSq = dr * dr + dg * dg + db * db;\n      return distSq <= tolSq;\n    };\n  }\n}\n\nexport function areColorsEqual(c1: RgbaU8, c2: RgbaU8): boolean {\n  return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;\n}\n\nfunction writePixel(\n  imgData: ImageData,\n  { x, y }: { x: number; y: number },\n  color: RgbaU8\n): void {\n  const { width, height, data } = imgData;\n\n  if (x >= width) {\n    throw new RangeError(\"X coordinate exceeded image width.\");\n  }\n  if (y >= height) {\n    throw new RangeError(\"Y coordinate exceeded image height.\");\n  }\n\n  const i = 4 * (y * width + x);\n\n  data[i] = color.r;\n  data[i + 1] = color.g;\n  data[i + 2] = color.b;\n  data[i + 3] = color.a;\n}\n\nfunction getWestNeighbor({\n  x,\n  y\n}: {\n  x: number;\n  y: number;\n}): Option<{ x: number; y: number }> {\n  if (x > 0) {\n    return Option.some({ x: x - 1, y });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getNorthNeighbor({\n  x,\n  y\n}: {\n  x: number;\n  y: number;\n}): Option<{ x: number; y: number }> {\n  if (y > 0) {\n    return Option.some({ x, y: y - 1 });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getEastNeighbor(\n  {\n    x,\n    y\n  }: {\n    x: number;\n    y: number;\n  },\n  width: number\n): Option<{ x: number; y: number }> {\n  if (x < width - 1) {\n    return Option.some({ x: x + 1, y });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getSouthNeighbor(\n  {\n    x,\n    y\n  }: {\n    x: number;\n    y: number;\n  },\n  height: number\n): Option<{ x: number; y: number }> {\n  if (y < height - 1) {\n    return Option.some({ x, y: y + 1 });\n  } else {\n    return Option.none();\n  }\n}\n","import React from \"react\";\nimport Option from \"@kylejlin/option\";\nimport { SketchPicker, ColorResult } from \"react-color\";\n\nimport \"./App.css\";\n\nimport Canvas from \"./components/Canvas\";\n\nimport {\n  History,\n  Snapshot,\n  Fill,\n  ColorComparisonOptions,\n  FillUpdate,\n  RgbaU8\n} from \"./types\";\n\nimport readFileAsHtmlImage from \"./readFileAsHtmlImage\";\nimport {\n  getImgData,\n  getImgDataAfterFloodFill,\n  getPixelColorAt,\n  getRgbaU8FromRgb,\n  areColorsEqual\n} from \"./image\";\n\nexport default class App extends React.Component<{}, State> {\n  private mainCanvasRef: React.RefObject<HTMLCanvasElement>;\n  private snapshotsRef: React.RefObject<HTMLDivElement>;\n  private currentSnapshotRef: React.RefObject<HTMLCanvasElement>;\n\n  constructor(props: {}) {\n    super(props);\n\n    // @ts-ignore\n    window.app = this;\n\n    this.state = {\n      fileName: Option.none(),\n      shouldBackdropBeCheckered: true,\n      backdropColorHex: \"#222222\",\n      history: Option.none(),\n      replacementColor: Option.none(),\n      toleranceStr: \"0\",\n      shouldCompareAlpha: false,\n      isAdjustingPreviousFill: false,\n      isSelectingReplacementColorFromCurrentSnapshot: false,\n      pendingFillUpdate: Option.none()\n    };\n\n    this.bindMethods();\n\n    this.mainCanvasRef = React.createRef();\n    this.snapshotsRef = React.createRef();\n    this.currentSnapshotRef = React.createRef();\n  }\n\n  bindMethods() {\n    this.onKeyDown = this.onKeyDown.bind(this);\n\n    this.applyPendingFillUpdate = this.applyPendingFillUpdate.bind(this);\n\n    this.onFileChange = this.onFileChange.bind(this);\n    this.onReplacementColorChangeComplete = this.onReplacementColorChangeComplete.bind(\n      this\n    );\n    this.onCanvasClick = this.onCanvasClick.bind(this);\n    this.onToleranceChange = this.onToleranceChange.bind(this);\n    this.onShouldCompareAlphaChange = this.onShouldCompareAlphaChange.bind(\n      this\n    );\n    this.onUndoClick = this.onUndoClick.bind(this);\n    this.onRedoClick = this.onRedoClick.bind(this);\n    this.onBackdropColorChangeComplete = this.onBackdropColorChangeComplete.bind(\n      this\n    );\n    this.onShouldBackdropBeCheckeredChange = this.onShouldBackdropBeCheckeredChange.bind(\n      this\n    );\n    this.onStopAdjustingPreviousFillClick = this.onStopAdjustingPreviousFillClick.bind(\n      this\n    );\n    this.onAdjustPreviousFillClick = this.onAdjustPreviousFillClick.bind(this);\n    this.onIsSelectingReplacementColorFromCurrentSnapshotChange = this.onIsSelectingReplacementColorFromCurrentSnapshotChange.bind(\n      this\n    );\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  onKeyDown(event: KeyboardEvent) {\n    if (\n      document.activeElement === document.body &&\n      event.key.toLowerCase() === \"z\" &&\n      (event.ctrlKey || event.metaKey) &&\n      !this.state.isAdjustingPreviousFill\n    ) {\n      event.preventDefault();\n      if (event.shiftKey) {\n        this.state.history.ifSome(history => {\n          if (history.canRedo()) {\n            this.redo();\n          }\n        });\n      } else {\n        this.state.history.ifSome(history => {\n          if (history.canUndo()) {\n            this.undo();\n          }\n        });\n      }\n    }\n  }\n\n  render() {\n    return (\n      <>\n        <header>\n          <h1>Flood fill</h1>\n        </header>\n        <main>\n          <div>\n            {this.state.fileName.match({\n              none: () => (\n                <label>\n                  Upload an image{\" \"}\n                  <input\n                    type=\"file\"\n                    accept=\"image/png, image/jpg, image/jpeg, image/gif\"\n                    onChange={this.onFileChange}\n                  />\n                </label>\n              ),\n              some: fileName =>\n                this.state.history.match({\n                  none: () => <p>Loading {fileName}...</p>,\n                  some: () => (\n                    <>\n                      <p>Successfully uploaded {fileName}</p>\n                      <label>\n                        Choose another image{\" \"}\n                        <input\n                          type=\"file\"\n                          accept=\"image/png, image/jpg, image/jpeg, image/gif\"\n                          onChange={this.onFileChange}\n                        />\n                      </label>\n                    </>\n                  )\n                })\n            })}\n          </div>\n\n          {this.state.replacementColor.match({\n            none: () => null,\n            some: color => (\n              <div>\n                {this.state.isAdjustingPreviousFill ? (\n                  <div>\n                    <h3>Adjusting the previous fill</h3>\n\n                    {this.state\n                      .isSelectingReplacementColorFromCurrentSnapshot ? (\n                      <p>\n                        Any changes you make to the fill settings will adjust\n                        the previous fill. Since you have the \"Select replacment\n                        color from image\" option checked, clicking on the image\n                        will adjust the previous fill's replacement color to the\n                        clicked color.\n                      </p>\n                    ) : (\n                      <p>\n                        Any changes you make to the fill settings (including\n                        changing the flood start location by clicking on the\n                        image) will adjust the previous fill.\n                      </p>\n                    )}\n\n                    <button onClick={this.onStopAdjustingPreviousFillClick}>\n                      Stop adjusting\n                    </button>\n                  </div>\n                ) : (\n                  <div>\n                    <h3>Adjusting next fill</h3>\n\n                    {this.state\n                      .isSelectingReplacementColorFromCurrentSnapshot ? (\n                      <p>\n                        Any changes you make to the fill settings will apply to\n                        the next fill performed. Since you have the \"Select\n                        replacment color from image\" option checked, clicking on\n                        the image will set the next fill's replacement color to\n                        the clicked color.\n                      </p>\n                    ) : (\n                      <p>\n                        Any changes you make to the fill settings will apply to\n                        the next fill performed. Clicking on the image will\n                        cause a new fill to be performed.\n                      </p>\n                    )}\n\n                    <button\n                      onClick={this.onAdjustPreviousFillClick}\n                      disabled={this.state.history\n                        .andThen(history =>\n                          history.current().andThen(current => current.fill)\n                        )\n                        .isNone()}\n                    >\n                      Adjust previous fill\n                    </button>\n                  </div>\n                )}\n\n                <div>\n                  <label>\n                    Select replacement color from image:{\" \"}\n                    <input\n                      type=\"checkbox\"\n                      checked={\n                        this.state\n                          .isSelectingReplacementColorFromCurrentSnapshot\n                      }\n                      onChange={\n                        this\n                          .onIsSelectingReplacementColorFromCurrentSnapshotChange\n                      }\n                    />\n                  </label>\n                </div>\n\n                <div>\n                  <label>\n                    Replacement color:\n                    <SketchPicker\n                      color={color}\n                      onChangeComplete={this.onReplacementColorChangeComplete}\n                    />\n                  </label>\n                </div>\n\n                <section>\n                  <h3>Backdrop</h3>\n                  <label>\n                    Use checkerboard:{\" \"}\n                    <input\n                      type=\"checkbox\"\n                      checked={this.state.shouldBackdropBeCheckered}\n                      onChange={this.onShouldBackdropBeCheckeredChange}\n                    />\n                    {!this.state.shouldBackdropBeCheckered && (\n                      <label>\n                        Color:\n                        <SketchPicker\n                          disableAlpha\n                          color={this.state.backdropColorHex}\n                          onChangeComplete={this.onBackdropColorChangeComplete}\n                        />\n                      </label>\n                    )}\n                  </label>\n                </section>\n\n                <label>\n                  Tolerance:{\" \"}\n                  <input\n                    type=\"number\"\n                    value={this.state.toleranceStr}\n                    onChange={this.onToleranceChange}\n                  />\n                  <input\n                    type=\"range\"\n                    value={this.state.toleranceStr}\n                    onChange={this.onToleranceChange}\n                    min={0}\n                    max={Math.ceil(\n                      getMaxEuclideanDistance(this.state.shouldCompareAlpha)\n                    )}\n                  />\n                </label>\n                <label>\n                  Compare alpha values:{\" \"}\n                  <input\n                    type=\"checkbox\"\n                    checked={this.state.shouldCompareAlpha}\n                    onChange={this.onShouldCompareAlphaChange}\n                  />\n                </label>\n              </div>\n            )\n          })}\n\n          {this.state.history\n            .andThen(history => history.current())\n            .match({\n              none: () => null,\n              some: snapshot => (\n                <div\n                  className={\n                    \"MainCanvasContainer\" +\n                    (this.state.shouldBackdropBeCheckered\n                      ? \" Checkerboard\"\n                      : \"\")\n                  }\n                  {...(this.state.shouldBackdropBeCheckered\n                    ? {}\n                    : {\n                        style: {\n                          backgroundColor: this.state.backdropColorHex\n                        }\n                      })}\n                >\n                  <Canvas\n                    imgData={snapshot.imgDataAfterFill}\n                    canvasRef={this.mainCanvasRef}\n                    className={\"MainCanvas\"}\n                    onClick={this.onCanvasClick}\n                  />\n                </div>\n              )\n            })}\n\n          {this.state.history.match({\n            none: () => null,\n            some: history => (\n              <div>\n                <h3>History</h3>\n\n                {this.state.isAdjustingPreviousFill && (\n                  <p>\n                    You cannot undo or redo because you are adjusting the\n                    previous fill. To be able to undo and redo, stop adjusting\n                    the previous fill.\n                  </p>\n                )}\n\n                <button\n                  onClick={this.onUndoClick}\n                  disabled={\n                    !history.canUndo() || this.state.isAdjustingPreviousFill\n                  }\n                >\n                  Undo\n                </button>\n\n                <button\n                  onClick={this.onRedoClick}\n                  disabled={\n                    !history.canRedo() || this.state.isAdjustingPreviousFill\n                  }\n                >\n                  Redo\n                </button>\n\n                {!this.state.isAdjustingPreviousFill && (\n                  <p>\n                    You can also Undo by pressing <kbd>Ctrl-Z</kbd> or{\" \"}\n                    <kbd>Cmd-Z</kbd> and Redo by pressing{\" \"}\n                    <kbd>Ctrl-Shift-Z</kbd> or <kbd>Cmd-Shift-Z</kbd>.\n                  </p>\n                )}\n\n                <div className=\"Snapshots\" ref={this.snapshotsRef}>\n                  {history.past().map((snapshot, i) => (\n                    <Canvas\n                      key={i}\n                      imgData={snapshot.imgDataAfterFill}\n                      className=\"HistorySnapshot NonFinalSnapshot\"\n                    />\n                  ))}\n                  {history.current().match({\n                    none: () => null,\n                    some: snapshot => (\n                      <Canvas\n                        imgData={snapshot.imgDataAfterFill}\n                        className={\n                          \"HistorySnapshot CurrentSnapshot\" +\n                          (history.future().length > 0\n                            ? \" NonFinalSnapshot\"\n                            : \"\")\n                        }\n                        canvasRef={this.currentSnapshotRef}\n                      />\n                    )\n                  })}\n                  {history.future().map((snapshot, i, { length }) => (\n                    <Canvas\n                      key={i}\n                      imgData={snapshot.imgDataAfterFill}\n                      className={\n                        \"HistorySnapshot\" +\n                        (i < length - 1 ? \" NonFinalSnapshot\" : \"\")\n                      }\n                    />\n                  ))}\n                </div>\n              </div>\n            )\n          })}\n        </main>\n      </>\n    );\n  }\n\n  onFileChange(event: React.ChangeEvent<HTMLInputElement>) {\n    const { files } = event.target;\n    if (files !== null) {\n      const file = files[0];\n      if (file instanceof File && /\\.(jpe?g|png|gif)$/i.test(file.name)) {\n        this.setState({\n          fileName: Option.some(file.name),\n          history: Option.none(),\n          replacementColor: this.state.replacementColor.or(\n            Option.some({ r: 0, g: 0, b: 0, a: 0 })\n          ),\n          isAdjustingPreviousFill: false,\n          pendingFillUpdate: Option.none()\n        });\n\n        readFileAsHtmlImage(file).then(img => {\n          const imgDataAfterFill = getImgData(img);\n          const snapshot: Snapshot = {\n            fill: Option.none(),\n            imgDataAfterFill\n          };\n\n          this.setState({\n            history: Option.some(History.fromCurrent(snapshot))\n          });\n        });\n      }\n    }\n  }\n\n  onReplacementColorChangeComplete(color: ColorResult) {\n    const replacementColor = getRgbaU8FromRgb(color.rgb);\n    this.setState({ replacementColor: Option.some(replacementColor) });\n\n    if (this.state.isAdjustingPreviousFill) {\n      this.adjustPreviousFill({ replacementColor });\n    }\n  }\n\n  onCanvasClick(event: React.MouseEvent<HTMLCanvasElement>) {\n    Option.all([\n      this.state.replacementColor,\n      this.state.history,\n      this.state.history.andThen(history => history.current())\n    ]).ifSome(([replacementColor, history, currentSnapshot]) => {\n      const { clientX, clientY } = event;\n      const canvas = this.mainCanvasRef.current!;\n      const dataBefore = currentSnapshot.imgDataAfterFill;\n\n      const box = canvas.getBoundingClientRect();\n      const localX = Math.round(clientX - box.left);\n      const localY = Math.round(clientY - box.top);\n      const startLocation = { x: localX, y: localY };\n\n      if (\n        areColorsEqual(\n          replacementColor,\n          getPixelColorAt(dataBefore, startLocation)\n        )\n      ) {\n        return;\n      }\n\n      if (this.state.isAdjustingPreviousFill) {\n        if (this.state.isSelectingReplacementColorFromCurrentSnapshot) {\n          const newReplacementColor = getPixelColorAt(\n            dataBefore,\n            startLocation\n          );\n          this.adjustPreviousFill({ replacementColor: newReplacementColor });\n        } else {\n          this.adjustPreviousFill({ startLocation });\n        }\n      } else {\n        if (this.state.isSelectingReplacementColorFromCurrentSnapshot) {\n          const newReplacementColor = getPixelColorAt(\n            dataBefore,\n            startLocation\n          );\n          this.setState({ replacementColor: Option.some(newReplacementColor) });\n        } else {\n          const colorComparisonOptions: ColorComparisonOptions = {\n            tolerance: parseInt(this.state.toleranceStr, 10),\n            shouldCompareAlpha: this.state.shouldCompareAlpha\n          };\n          const fill: Fill = {\n            startLocation,\n            replacementColor,\n            colorComparisonOptions\n          };\n          const imgDataAfterFill = getImgDataAfterFloodFill(dataBefore, fill);\n          const newSnapshot: Snapshot = {\n            fill: Option.some(fill),\n            imgDataAfterFill\n          };\n\n          history.push(newSnapshot);\n          this.forceUpdate();\n        }\n      }\n    });\n  }\n\n  onToleranceChange(event: React.ChangeEvent<HTMLInputElement>) {\n    const toleranceStr = event.target.value;\n    this.setState({ toleranceStr });\n\n    if (this.state.isAdjustingPreviousFill) {\n      this.adjustPreviousFill({\n        colorComparisonOptions: { tolerance: parseInt(toleranceStr, 10) }\n      });\n    }\n  }\n\n  onShouldCompareAlphaChange(event: React.ChangeEvent<HTMLInputElement>) {\n    const shouldCompareAlpha = event.target.checked;\n    this.setState({ shouldCompareAlpha });\n\n    if (this.state.isAdjustingPreviousFill) {\n      if (event.target.type === \"slider\") {\n        this.debouncedAdjustPreviousFill({\n          colorComparisonOptions: { shouldCompareAlpha }\n        });\n      } else {\n        this.adjustPreviousFill({\n          colorComparisonOptions: { shouldCompareAlpha }\n        });\n      }\n    }\n  }\n\n  debouncedAdjustPreviousFill(fillUpdate: FillUpdate) {\n    this.state.pendingFillUpdate.ifNone(() => {\n      this.setState({ pendingFillUpdate: Option.some(fillUpdate) });\n      requestAnimationFrame(this.applyPendingFillUpdate);\n    });\n  }\n\n  applyPendingFillUpdate() {\n    this.state.pendingFillUpdate.ifSome(update => {\n      this.clearPendingFillUpdate();\n      this.adjustPreviousFill(update);\n    });\n  }\n\n  clearPendingFillUpdate() {\n    this.setState({ pendingFillUpdate: Option.none() });\n  }\n\n  adjustPreviousFill(fillUpdate: FillUpdate) {\n    // Prevent a pending update from overwriting this update in the future.\n    this.clearPendingFillUpdate();\n\n    const history = this.state.history.expect(\n      \"Cannot call adjustPreviousFill if there is no history\"\n    );\n    const currentSnapshot = history\n      .current()\n      .expect(\"Cannot call adjustPreviousFill if there is no current snapshot\");\n    const previousSnapshot = history\n      .prev()\n      .expect(\n        \"Cannot call adjustPreviousFill if there is no previous snapshot\"\n      );\n    const previousFill = currentSnapshot.fill.expect(\n      \"Cannot call adjustPreviousFill if the current snapshot was not created by flood-fill\"\n    );\n    const updatedFill = applyFillUpdate(previousFill, fillUpdate);\n\n    currentSnapshot.fill = Option.some(updatedFill);\n    currentSnapshot.imgDataAfterFill = getImgDataAfterFloodFill(\n      previousSnapshot.imgDataAfterFill,\n      updatedFill\n    );\n    this.forceUpdate();\n  }\n\n  onUndoClick() {\n    this.undo();\n  }\n\n  undo() {\n    this.state.history\n      .expect(\"Cannot call onUndoClick if history is none\")\n      .undo();\n    this.forceUpdate(() => {\n      this.scrollHistoryToCurrentSnapshot();\n    });\n  }\n\n  onRedoClick() {\n    this.redo();\n  }\n\n  redo() {\n    this.state.history\n      .expect(\"Cannot call onRedoClick if history is none\")\n      .redo();\n    this.forceUpdate(() => {\n      this.scrollHistoryToCurrentSnapshot();\n    });\n  }\n\n  onBackdropColorChangeComplete(color: ColorResult) {\n    this.setState({ backdropColorHex: color.hex });\n  }\n\n  onShouldBackdropBeCheckeredChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ) {\n    this.setState({ shouldBackdropBeCheckered: event.target.checked });\n  }\n\n  scrollHistoryToCurrentSnapshot() {\n    const currentSnapshot = this.currentSnapshotRef.current;\n    if (currentSnapshot !== null) {\n      const snapshotsContainer = this.snapshotsRef.current!;\n      const snapshotsContainerWidth = snapshotsContainer.getBoundingClientRect()\n        .width;\n      const currentSnapshotRight = currentSnapshot.getBoundingClientRect()\n        .right;\n      snapshotsContainer.scroll(\n        currentSnapshotRight +\n          snapshotsContainer.scrollLeft -\n          snapshotsContainerWidth,\n        0\n      );\n    }\n  }\n\n  onStopAdjustingPreviousFillClick() {\n    this.setState({ isAdjustingPreviousFill: false });\n  }\n\n  onAdjustPreviousFillClick() {\n    this.setState({ isAdjustingPreviousFill: true });\n  }\n  onIsSelectingReplacementColorFromCurrentSnapshotChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ) {\n    this.setState({\n      isSelectingReplacementColorFromCurrentSnapshot: event.target.checked\n    });\n  }\n}\n\ninterface State {\n  fileName: Option<string>;\n  shouldBackdropBeCheckered: boolean;\n  backdropColorHex: string;\n  history: Option<History<Snapshot>>;\n  replacementColor: Option<RgbaU8>;\n  toleranceStr: string;\n  shouldCompareAlpha: boolean;\n  isAdjustingPreviousFill: boolean;\n  isSelectingReplacementColorFromCurrentSnapshot: boolean;\n  pendingFillUpdate: Option<FillUpdate>;\n}\n\nfunction applyFillUpdate(prevFill: Fill, update: FillUpdate): Fill {\n  const newTolerance =\n    update.colorComparisonOptions && update.colorComparisonOptions.tolerance;\n  const newShouldCompareAlpha =\n    update.colorComparisonOptions &&\n    update.colorComparisonOptions.shouldCompareAlpha;\n  return {\n    startLocation: update.startLocation || prevFill.startLocation,\n    replacementColor: update.replacementColor || prevFill.replacementColor,\n    colorComparisonOptions: {\n      tolerance:\n        newTolerance !== undefined\n          ? newTolerance\n          : prevFill.colorComparisonOptions.tolerance,\n      shouldCompareAlpha:\n        newShouldCompareAlpha !== undefined\n          ? newShouldCompareAlpha\n          : prevFill.colorComparisonOptions.shouldCompareAlpha\n    }\n  };\n}\n\nfunction getMaxEuclideanDistance(shouldCompareAlpha: boolean): number {\n  if (shouldCompareAlpha) {\n    return Math.hypot(255, 255, 255, 255);\n  } else {\n    return Math.hypot(255, 255, 255);\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}