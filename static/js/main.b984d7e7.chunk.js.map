{"version":3,"sources":["components/Canvas.tsx","types.ts","readFileAsHtmlImage.ts","image.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Canvas","props","canvasRef","React","createRef","imgData","this","clone","omitNonNormalProps","ref","width","height","renderImgData","current","getContext","putImageData","Component","Queue","data","dequeueIndex","item","push","hasItem","undefined","Error","length","History","undoStack","redoStack","history","empty","canUndo","undone","pop","canRedo","redone","Option","none","some","slice","reverse","readFileAsHtmlImage","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","error","readAsDataURL","readFileAsDataUrl","then","url","img","document","createElement","src","getImgDataAfterFloodFill","originalData","floodStartLocation","replacementRgbColor","options","original","newData","ImageData","replacementColor","getRgbaU8FromRgb","targetColor","getPixelColorAt","isColorCloseEnoughToTarget","tolerance","shouldCompareAlpha","tolSq","color","dr","r","dg","g","db","b","da","a","getColorComparator","areColorsEqual","imgWidth","imgHeight","writePixel","queue","enqueue","location","dequeue","getWestNeighbor","ifSome","neighbor","neighborColor","getNorthNeighbor","getEastNeighbor","getSouthNeighbor","rgb","Math","floor","x","y","RangeError","i","c1","c2","App","mainCanvasRef","window","app","state","originalImg","fileName","shouldBackdropBeCheckered","backdropColorHex","toleranceStr","bindMethods","onKeyDown","bind","onFileChange","onReplacementColorChangeComplete","onCanvasClick","onToleranceChange","onShouldCompareAlphaChange","onUndoClick","onRedoClick","onBackdropColorChangeComplete","onShouldBackdropBeCheckeredChange","removeEventListener","event","activeElement","body","key","toLowerCase","ctrlKey","metaKey","preventDefault","shiftKey","redo","forceUpdate","undo","match","type","accept","onChange","onChangeComplete","checked","disableAlpha","value","andThen","className","style","backgroundColor","onClick","disabled","past","map","future","files","target","File","test","name","canvas","ctx","drawImage","getImageData","getImgData","setState","fromCurrent","all","currentImgData","clientX","clientY","dataBefore","box","getBoundingClientRect","round","left","top","dataAfter","parseInt","expect","hex","Boolean","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.b984d7e7.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default class Canvas extends React.Component<Props> {\n  private canvasRef: React.RefObject<HTMLCanvasElement>;\n\n  constructor(props: Props) {\n    super(props);\n\n    this.canvasRef = props.canvasRef || React.createRef();\n  }\n\n  render() {\n    const { imgData } = this.props;\n    return (\n      <canvas\n        {...omitNonNormalProps(this.props)}\n        ref={this.canvasRef}\n        width={imgData.width}\n        height={imgData.height}\n      />\n    );\n  }\n\n  componentDidMount() {\n    this.renderImgData();\n  }\n\n  componentDidUpdate() {\n    this.renderImgData();\n  }\n\n  renderImgData() {\n    const canvas = this.canvasRef.current!;\n    const ctx = canvas.getContext(\"2d\")!;\n    ctx.putImageData(this.props.imgData, 0, 0);\n  }\n}\n\ninterface Props extends React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  imgData: ImageData;\n  canvasRef?: React.RefObject<HTMLCanvasElement>;\n}\n\nfunction omitNonNormalProps(\n  props: Props\n): React.CanvasHTMLAttributes<HTMLCanvasElement> {\n  const clone = { ...props };\n\n  delete clone.imgData;\n  delete clone.canvasRef;\n\n  return clone;\n}\n","import Option from \"@kylejlin/option\";\n\nexport interface RgbaU8 {\n  r: number;\n  b: number;\n  g: number;\n  a: number;\n}\n\nexport interface ColorComparisonOptions {\n  tolerance: number;\n  shouldCompareAlpha: boolean;\n}\n\nexport class Queue<T> {\n  private data: (T | undefined)[];\n  private dequeueIndex: number;\n\n  static empty<T>(): Queue<T> {\n    return new Queue([]);\n  }\n\n  private constructor(data: T[]) {\n    this.data = data;\n    this.dequeueIndex = 0;\n  }\n\n  enqueue(item: T): void {\n    this.data.push(item);\n  }\n\n  dequeue(): T {\n    if (this.hasItem()) {\n      const item = this.data[this.dequeueIndex];\n      this.data[this.dequeueIndex] = undefined;\n      this.dequeueIndex++;\n      return item!;\n    } else {\n      throw new Error(\"Cannot dequeue an item from an empty queue.\");\n    }\n  }\n\n  hasItem(): boolean {\n    return this.dequeueIndex < this.data.length;\n  }\n}\n\nexport class History<T> {\n  private undoStack: T[];\n  private redoStack: T[];\n\n  static fromCurrent<T>(current: T): History<T> {\n    const history: History<T> = History.empty();\n    history.push(current);\n    return history;\n  }\n\n  static empty<T>(): History<T> {\n    return new History();\n  }\n\n  private constructor() {\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  undo(): T {\n    if (!this.canUndo()) {\n      throw new Error(\"Cannot undo nothing.\");\n    }\n\n    const undone = this.undoStack.pop()!;\n    this.redoStack.push(undone);\n    return undone;\n  }\n\n  canUndo(): boolean {\n    return this.undoStack.length > 1;\n  }\n\n  redo(): T {\n    if (!this.canRedo()) {\n      throw new Error(\"Cannot redo nothing.\");\n    }\n\n    const redone = this.redoStack.pop()!;\n    this.undoStack.push(redone);\n    return redone;\n  }\n\n  canRedo(): boolean {\n    return this.redoStack.length > 0;\n  }\n\n  push(item: T) {\n    this.undoStack.push(item);\n    this.redoStack = [];\n  }\n\n  current(): Option<T> {\n    if (this.undoStack.length === 0) {\n      return Option.none();\n    } else {\n      return Option.some(this.undoStack[this.undoStack.length - 1]);\n    }\n  }\n\n  past(): T[] {\n    return this.undoStack.slice(0, -1);\n  }\n\n  future(): T[] {\n    return this.redoStack.slice().reverse();\n  }\n}\n","export default function readFileAsHtmlImage(\n  file: File\n): Promise<HTMLImageElement> {\n  return readFileAsDataUrl(file).then(\n    url =>\n      new Promise((resolve, reject) => {\n        const img = document.createElement(\"img\");\n        img.src = url;\n        img.addEventListener(\"load\", () => resolve(img));\n        img.addEventListener(\"error\", reject);\n      })\n  );\n}\n\nfunction readFileAsDataUrl(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", () => resolve(reader.result as string));\n    reader.addEventListener(\"error\", () => reject(reader.error));\n    reader.readAsDataURL(file);\n  });\n}\n","import Option from \"@kylejlin/option\";\nimport { RGBColor } from \"react-color\";\n\nimport { ColorComparisonOptions, Queue, RgbaU8 } from \"./types\";\n\nexport function getImgData(img: HTMLImageElement): ImageData {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext(\"2d\")!;\n  ctx.drawImage(img, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\nexport function doesTargetColorEqualReplacementColor(\n  imgData: ImageData,\n  floodStartLocation: { x: number; y: number },\n  replacementRgbColor: RGBColor\n): boolean {\n  const replacementColor = getRgbaU8FromRgb(replacementRgbColor);\n  const targetColor = getPixelColorAt(imgData, floodStartLocation);\n  return areColorsEqual(replacementColor, targetColor);\n}\n\nexport function getImgDataAfterFloodFill(\n  originalData: ImageData,\n  floodStartLocation: { x: number; y: number },\n  replacementRgbColor: RGBColor,\n  options: ColorComparisonOptions\n): ImageData {\n  const newData = cloneImgData(originalData);\n  const replacementColor = getRgbaU8FromRgb(replacementRgbColor);\n  const targetColor = getPixelColorAt(newData, floodStartLocation);\n  const isColorCloseEnoughToTarget = getColorComparator(targetColor, options);\n\n  if (areColorsEqual(replacementColor, targetColor)) {\n    return newData;\n  }\n\n  const { width: imgWidth, height: imgHeight } = originalData;\n\n  writePixel(newData, floodStartLocation, replacementColor);\n\n  const queue: Queue<{ x: number; y: number }> = Queue.empty();\n  queue.enqueue(floodStartLocation);\n\n  while (queue.hasItem()) {\n    const location = queue.dequeue();\n    getWestNeighbor(location).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getNorthNeighbor(location).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getEastNeighbor(location, imgWidth).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n    getSouthNeighbor(location, imgHeight).ifSome(neighbor => {\n      const neighborColor = getPixelColorAt(newData, neighbor);\n      if (\n        isColorCloseEnoughToTarget(neighborColor) &&\n        !areColorsEqual(replacementColor, neighborColor)\n      ) {\n        writePixel(newData, neighbor, replacementColor);\n        queue.enqueue(neighbor);\n      }\n    });\n  }\n\n  return newData;\n}\n\nfunction cloneImgData(original: ImageData): ImageData {\n  return new ImageData(original.data.slice(), original.width, original.height);\n}\n\nfunction getRgbaU8FromRgb(rgb: RGBColor): RgbaU8 {\n  return {\n    r: rgb.r,\n    g: rgb.g,\n    b: rgb.b,\n    a: Math.floor(255 * (rgb.a === undefined ? 1.0 : rgb.a))\n  };\n}\n\nfunction getPixelColorAt(\n  imgData: ImageData,\n  { x, y }: { x: number; y: number }\n): RgbaU8 {\n  const { width, height, data } = imgData;\n  if (x >= width) {\n    throw new RangeError(\"X coordinate exceeded image width.\");\n  }\n  if (y >= height) {\n    throw new RangeError(\"Y coordinate exceeded image height.\");\n  }\n  const i = 4 * (y * width + x);\n  return { r: data[i], g: data[i + 1], b: data[i + 2], a: data[i + 3] };\n}\n\nfunction getColorComparator(\n  targetColor: RgbaU8,\n  options: ColorComparisonOptions\n): (color: RgbaU8) => boolean {\n  const { tolerance, shouldCompareAlpha } = options;\n  const tolSq = tolerance * tolerance;\n\n  if (shouldCompareAlpha) {\n    return function isColorCloseEnoughToTarget(color: RgbaU8): boolean {\n      const dr = targetColor.r - color.r;\n      const dg = targetColor.g - color.g;\n      const db = targetColor.b - color.b;\n      const da = targetColor.a - color.a;\n      const distSq = dr * dr + dg * dg + db * db + da * da;\n      return distSq <= tolSq;\n    };\n  } else {\n    return function isColorCloseEnoughToTarget(color: RgbaU8): boolean {\n      const dr = targetColor.r - color.r;\n      const dg = targetColor.g - color.g;\n      const db = targetColor.b - color.b;\n      const distSq = dr * dr + dg * dg + db * db;\n      return distSq <= tolSq;\n    };\n  }\n}\n\nfunction areColorsEqual(c1: RgbaU8, c2: RgbaU8): boolean {\n  return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;\n}\n\nfunction writePixel(\n  imgData: ImageData,\n  { x, y }: { x: number; y: number },\n  color: RgbaU8\n): void {\n  const { width, height, data } = imgData;\n\n  if (x >= width) {\n    throw new RangeError(\"X coordinate exceeded image width.\");\n  }\n  if (y >= height) {\n    throw new RangeError(\"Y coordinate exceeded image height.\");\n  }\n\n  const i = 4 * (y * width + x);\n\n  data[i] = color.r;\n  data[i + 1] = color.g;\n  data[i + 2] = color.b;\n  data[i + 3] = color.a;\n}\n\nfunction getWestNeighbor({\n  x,\n  y\n}: {\n  x: number;\n  y: number;\n}): Option<{ x: number; y: number }> {\n  if (x > 0) {\n    return Option.some({ x: x - 1, y });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getNorthNeighbor({\n  x,\n  y\n}: {\n  x: number;\n  y: number;\n}): Option<{ x: number; y: number }> {\n  if (y > 0) {\n    return Option.some({ x, y: y - 1 });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getEastNeighbor(\n  {\n    x,\n    y\n  }: {\n    x: number;\n    y: number;\n  },\n  width: number\n): Option<{ x: number; y: number }> {\n  if (x < width - 1) {\n    return Option.some({ x: x + 1, y });\n  } else {\n    return Option.none();\n  }\n}\n\nfunction getSouthNeighbor(\n  {\n    x,\n    y\n  }: {\n    x: number;\n    y: number;\n  },\n  height: number\n): Option<{ x: number; y: number }> {\n  if (y < height - 1) {\n    return Option.some({ x, y: y + 1 });\n  } else {\n    return Option.none();\n  }\n}\n","import React from \"react\";\nimport Option from \"@kylejlin/option\";\nimport { SketchPicker, ColorResult, RGBColor } from \"react-color\";\n\nimport \"./App.css\";\n\nimport Canvas from \"./components/Canvas\";\n\nimport { History } from \"./types\";\n\nimport readFileAsHtmlImage from \"./readFileAsHtmlImage\";\nimport {\n  doesTargetColorEqualReplacementColor,\n  getImgData,\n  getImgDataAfterFloodFill\n} from \"./image\";\n\nexport default class App extends React.Component<{}, State> {\n  private mainCanvasRef: React.RefObject<HTMLCanvasElement>;\n\n  constructor(props: {}) {\n    super(props);\n\n    // @ts-ignore\n    window.app = this;\n\n    this.state = {\n      originalImg: Option.none(),\n      fileName: Option.none(),\n      shouldBackdropBeCheckered: true,\n      backdropColorHex: \"#222222\",\n      history: Option.none(),\n      replacementColor: Option.none(),\n      toleranceStr: \"0\",\n      shouldCompareAlpha: false\n    };\n\n    this.bindMethods();\n\n    this.mainCanvasRef = React.createRef();\n  }\n\n  bindMethods() {\n    this.onKeyDown = this.onKeyDown.bind(this);\n\n    this.onFileChange = this.onFileChange.bind(this);\n    this.onReplacementColorChangeComplete = this.onReplacementColorChangeComplete.bind(\n      this\n    );\n    this.onCanvasClick = this.onCanvasClick.bind(this);\n    this.onToleranceChange = this.onToleranceChange.bind(this);\n    this.onShouldCompareAlphaChange = this.onShouldCompareAlphaChange.bind(\n      this\n    );\n    this.onUndoClick = this.onUndoClick.bind(this);\n    this.onRedoClick = this.onRedoClick.bind(this);\n    this.onBackdropColorChangeComplete = this.onBackdropColorChangeComplete.bind(\n      this\n    );\n    this.onShouldBackdropBeCheckeredChange = this.onShouldBackdropBeCheckeredChange.bind(\n      this\n    );\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  onKeyDown(event: KeyboardEvent) {\n    if (\n      document.activeElement === document.body &&\n      event.key.toLowerCase() === \"z\" &&\n      (event.ctrlKey || event.metaKey)\n    ) {\n      event.preventDefault();\n      if (event.shiftKey) {\n        this.state.history.ifSome(history => {\n          if (history.canRedo()) {\n            history.redo();\n            this.forceUpdate();\n          }\n        });\n      } else {\n        this.state.history.ifSome(history => {\n          if (history.canUndo()) {\n            history.undo();\n            this.forceUpdate();\n          }\n        });\n      }\n    }\n  }\n\n  render() {\n    return (\n      <>\n        <header>\n          <h1>Flood fill</h1>\n        </header>\n        <main>\n          <div>\n            {this.state.fileName.match({\n              none: () => (\n                <label>\n                  Upload an image{\" \"}\n                  <input\n                    type=\"file\"\n                    accept=\"image/png, image/jpg, image/jpeg, image/gif\"\n                    onChange={this.onFileChange}\n                  />\n                </label>\n              ),\n              some: fileName => <p>Successfully uploaded {fileName}</p>\n            })}\n          </div>\n\n          {this.state.replacementColor.match({\n            none: () => null,\n            some: color => (\n              <div>\n                <label>\n                  Replacement color:\n                  <SketchPicker\n                    color={color}\n                    onChangeComplete={this.onReplacementColorChangeComplete}\n                  />\n                </label>\n\n                <section>\n                  <h3>Backdrop</h3>\n                  <label>\n                    Use checkerboard:{\" \"}\n                    <input\n                      type=\"checkbox\"\n                      checked={this.state.shouldBackdropBeCheckered}\n                      onChange={this.onShouldBackdropBeCheckeredChange}\n                    />\n                    {!this.state.shouldBackdropBeCheckered && (\n                      <label>\n                        Color:\n                        <SketchPicker\n                          disableAlpha\n                          color={this.state.backdropColorHex}\n                          onChangeComplete={this.onBackdropColorChangeComplete}\n                        />\n                      </label>\n                    )}\n                  </label>\n                </section>\n\n                <label>\n                  Tolerance:{\" \"}\n                  <input\n                    type=\"number\"\n                    value={this.state.toleranceStr}\n                    onChange={this.onToleranceChange}\n                  />\n                </label>\n                <label>\n                  Compare alpha values:{\" \"}\n                  <input\n                    type=\"checkbox\"\n                    checked={this.state.shouldCompareAlpha}\n                    onChange={this.onShouldCompareAlphaChange}\n                  />\n                </label>\n              </div>\n            )\n          })}\n\n          {this.state.history\n            .andThen(history => history.current())\n            .match({\n              none: () => null,\n              some: imgData => (\n                <div\n                  className={\n                    \"MainCanvasContainer\" +\n                    (this.state.shouldBackdropBeCheckered\n                      ? \" Checkerboard\"\n                      : \"\")\n                  }\n                  {...(this.state.shouldBackdropBeCheckered\n                    ? {}\n                    : {\n                        style: {\n                          backgroundColor: this.state.backdropColorHex\n                        }\n                      })}\n                >\n                  <Canvas\n                    imgData={imgData}\n                    canvasRef={this.mainCanvasRef}\n                    className={\"MainCanvas\"}\n                    onClick={this.onCanvasClick}\n                  />\n                </div>\n              )\n            })}\n\n          {this.state.history.match({\n            none: () => null,\n            some: history => (\n              <div>\n                <h3>History</h3>\n                <div>\n                  <h4>Past</h4>\n\n                  <button\n                    onClick={this.onUndoClick}\n                    disabled={!history.canUndo()}\n                  >\n                    Undo\n                  </button>\n\n                  <div>\n                    {history.past().map((imgData, i, { length }) => (\n                      <Canvas\n                        key={i}\n                        imgData={imgData}\n                        className={\n                          \"HistorySnapshot\" +\n                          (i < length - 1 ? \" NonFinalSnapshot\" : \"\")\n                        }\n                      />\n                    ))}\n                  </div>\n                </div>\n                <div>\n                  <h4>Future</h4>\n\n                  <button\n                    onClick={this.onRedoClick}\n                    disabled={!history.canRedo()}\n                  >\n                    Redo\n                  </button>\n\n                  <div>\n                    {history.future().map((imgData, i, { length }) => (\n                      <Canvas\n                        key={i}\n                        imgData={imgData}\n                        className={\n                          \"HistorySnapshot\" +\n                          (i < length - 1 ? \" NonFinalSnapshot\" : \"\")\n                        }\n                      />\n                    ))}\n                  </div>\n                </div>\n              </div>\n            )\n          })}\n        </main>\n      </>\n    );\n  }\n\n  onFileChange(event: React.ChangeEvent<HTMLInputElement>) {\n    const { files } = event.target;\n    if (files !== null) {\n      const file = files[0];\n      if (file instanceof File && /\\.(jpe?g|png|gif)$/i.test(file.name)) {\n        readFileAsHtmlImage(file).then(img => {\n          const imgData = getImgData(img);\n\n          this.setState({\n            originalImg: Option.some(img),\n            fileName: Option.some(file.name),\n            history: Option.some(History.fromCurrent(imgData)),\n            replacementColor: Option.some({ r: 0, g: 0, b: 0, a: 0 })\n          });\n        });\n      }\n    }\n  }\n\n  onReplacementColorChangeComplete(color: ColorResult) {\n    this.setState({ replacementColor: Option.some(color.rgb) });\n  }\n\n  onCanvasClick(event: React.MouseEvent<HTMLCanvasElement>) {\n    Option.all([\n      this.state.replacementColor,\n      this.state.history,\n      this.state.history.andThen(history => history.current())\n    ]).ifSome(([replacementColor, history, currentImgData]) => {\n      const { clientX, clientY } = event;\n      const canvas = this.mainCanvasRef.current!;\n      const dataBefore = currentImgData;\n\n      const box = canvas.getBoundingClientRect();\n      const localX = Math.round(clientX - box.left);\n      const localY = Math.round(clientY - box.top);\n      const location = { x: localX, y: localY };\n\n      if (\n        doesTargetColorEqualReplacementColor(\n          dataBefore,\n          location,\n          replacementColor\n        )\n      ) {\n        return;\n      }\n\n      const options = {\n        tolerance: parseInt(this.state.toleranceStr, 10),\n        shouldCompareAlpha: this.state.shouldCompareAlpha\n      };\n\n      const dataAfter = getImgDataAfterFloodFill(\n        dataBefore,\n        location,\n        replacementColor,\n        options\n      );\n\n      history.push(dataAfter);\n      this.forceUpdate();\n    });\n  }\n\n  onToleranceChange(event: React.ChangeEvent<HTMLInputElement>) {\n    this.setState({ toleranceStr: event.target.value });\n  }\n\n  onShouldCompareAlphaChange(event: React.ChangeEvent<HTMLInputElement>) {\n    this.setState({ shouldCompareAlpha: event.target.checked });\n  }\n\n  onUndoClick() {\n    this.state.history\n      .expect(\"Cannot call onUndoClick if history is none\")\n      .undo();\n    this.forceUpdate();\n  }\n\n  onRedoClick() {\n    this.state.history\n      .expect(\"Cannot call onRedoClick if history is none\")\n      .redo();\n    this.forceUpdate();\n  }\n\n  onBackdropColorChangeComplete(color: ColorResult) {\n    this.setState({ backdropColorHex: color.hex });\n  }\n\n  onShouldBackdropBeCheckeredChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ) {\n    this.setState({ shouldBackdropBeCheckered: event.target.checked });\n  }\n}\n\ninterface State {\n  originalImg: Option<HTMLImageElement>;\n  fileName: Option<string>;\n  shouldBackdropBeCheckered: boolean;\n  backdropColorHex: string;\n  history: Option<History<ImageData>>;\n  replacementColor: Option<RGBColor>;\n  toleranceStr: string;\n  shouldCompareAlpha: boolean;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}